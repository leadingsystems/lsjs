<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LSJS Quick Reference</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.5;
        }
        h1, h2, h3 {
            color: #333;
        }
        pre, code {
            background: #f5f5f5;
            padding: 5px;
            border-radius: 4px;
            font-family: Consolas, monospace;
            font-size: 14px;
        }
        pre {
            overflow-x: auto;
            padding: 10px;
        }
        hr {
            margin: 30px 0;
        }
    </style>
</head>
<body>
<h1>LSJS Quick Reference — Leading Systems JavaScript Framework</h1>
<p><strong>Version:</strong> Internal documentation with current conventions, patterns, and best practices.</p>
<hr>
<h2>1. Overview</h2>
<ul>
    <li><strong>LSJS</strong> is a <strong>modular MVC‑like front‑end JS framework</strong> used in the
        <strong>Merconis</strong> shop system.
    </li>
    <li>Modules can exist inside:
        <ul>
            <li><code>lsjs/core/modules</code> → reusable core modules.</li>
            <li><code>lsjs/app/modules</code> → app‑specific modules.</li>
        </ul>
    </li>
    <li><code>app.js</code> defines which modules are initialized at runtime.</li>
</ul>
<hr>
<h2>2. Module Structure</h2>
<p>A typical LSJS module consists of up to three components:</p>
<pre>modules/
  moduleName/
    controller.js
    view.js
    models/
      options.js
</pre>
<h3>Roles in MVC</h3>
<ul>
  <li><strong>Controller</strong>: Coordinates logic, data flow between Models, and between Models and View. Avoids direct DOM manipulation unless unavoidable.</li>
  <li><strong>View</strong>: Owns <code>__el_container</code>, performs DOM lookups, manipulations, and binds UI event handlers. All UI behaviour and visual state changes should go in the View.</li>
  <li><strong>Model</strong>: Holds data and configuration; Views/Controllers use it for logic and rendering decisions.</li>
</ul>
<h3>controller.js</h3>
<pre><code>lsjs.addControllerClass(str_moduleName, obj_classdef);
</code></pre>
<p>For *visual UI modules*, Controller can remain minimal if no coordination logic is needed.</p>
<h3>view.js</h3>
<pre><code>lsjs.addViewClass(str_moduleName, obj_classdef);
</code></pre>
<p>Handles all UI work using <code>this.__el_container</code> as the instance root DOM node.</p>
<h3>models/options.js</h3>
<p>Stores default configuration and merges user-provided overrides. In compiled LSJS, wrapper code is injected automatically — the file should only contain <code>obj_classdef_model</code> definition.</p>
<pre><code>var obj_classdef_model = {
    name: 'options',
    data: {},
    start: function() {
        this.data = {
            str_containerSelector: '',
            bln_doNotUseAjax: false
        };
    },
    set: function(obj_options) {
        Object.merge(this.data, obj_options);
        this.__module.onModelLoaded();
    }
};
</code></pre>
<hr>
<h2>3. Creating a Simple Module</h2>
<ol>
    <li>Create folder:
        <pre>lsjs/app/modules/myModule/</pre>
    </li>
    <li>controller.js:
        <pre><code>(function() {
    var str_moduleName = 'myModule';
    var obj_classdef = {
        start: function() {
            console.log('Module started!');
        }
    };
    lsjs.addControllerClass(str_moduleName, obj_classdef);
    lsjs.__moduleHelpers[str_moduleName] = {
        self: null,
        start: function(obj_options) {
            this.self = lsjs.createModule({ __name: str_moduleName });
            if (this.self.__models &amp;&amp; this.self.__models.options) {
                this.self.__models.options.set(obj_options || {});
            }
        }
    };
})();
</code></pre>
    </li>
    <li>Start in app.js:
<pre><code>lsjs.__moduleHelpers.myModule.start({ /* options */ });
</code></pre>
    </li>
</ol>
<hr>
<h2>4. App Initialization Flow (app.js)</h2>
<pre><code>lsjs.__moduleHelpers.someModule.start({
    str_containerSelector: '.some-selector',
    someOption: true
});
</code></pre>
<p>Flow: <br> <code>Controller → Model(s) → View</code></p>
<hr>
<h2>5. Template Handling</h2>
<p>Provided by <code>lsjs_templateHandler.js</code>:</p>
        <ul>
            <li><code>lsjs.tpl.add(...)</code> → append rendered template as child.</li>
            <li><code>lsjs.tpl.replace(...)</code> → replace all children, then append.</li>
        </ul>
<pre><code>lsjs.tpl.register({
    myTemplate: function(data) { /* return HTML */ }
}, 'moduleName');
</code></pre>
<hr>
<h2>6. Key LSJS APIs</h2>
<ul>
    <li><code>lsjs.createModule({...})</code> → create a module instance. Accepts extra arguments that will be available in <code>this.__module.obj_args</code>.</li>
    <li><code>lsjs.addControllerClass(name, def)</code> / <code>lsjs.addViewClass(name, def)</code></li>
    <li><code>lsjs.__moduleHelpers</code> registry for starting/stopping modules</li>
    <li><code>this.registerElements(container, namespace)</code> in views auto-registers DOM refs</li>
</ul>
<hr>
<h2>7. Patterns to Follow</h2>
<ul>
    <li>Always register app-startable modules in <code>lsjs.__moduleHelpers</code>.</li>
    <li>UI logic with <code>__el_container</code> belongs in the View.</li>
    <li>Keep <code>.start()</code> minimal in Controller unless coordinating data flow.</li>
    <li>Use models/options.js for default config+merges.</li>
    <li>Enhance existing DOM, when possible, to allow server rendering + progressive enhancement.</li>
</ul>
<hr>
<h2>8. Manager/Instance Pattern</h2>
<p>
For modules that can have multiple independent UI instances, LSJS uses a <strong>Manager/Instance</strong> pattern.
The Manager module scans the DOM for relevant containers and creates one Instance module for each container.
</p>
<h3>Directory Structure</h3>
<p>
Both Manager and Instance are separate LSJS modules, inside a common parent directory:
</p>
<pre>
modules/
  myModule/
    myModuleManager/
      controller.js   &lt;-- Manager needs only this file
    myModuleInstance/
      controller.js
      view.js
      models/
        options.js   (optional, if instance needs config)
</pre>
<p>
The Manager’s <code>controller.js</code> is the <strong>only file</strong> required for a Manager module — it has no View or Model because it does not directly handle DOM logic.
Its sole purpose is to find relevant DOM containers and create Instance modules.
</p>

<h3>Passing Options from Manager to Instances</h3>
<p>
The correct way to pass configuration from a Manager to its Instances is <strong>not</strong> calling <code>this.self.start()</code> or similar.
Instead:
</p>
<ol>
<li>Pass options into <code>lsjs.createModule()</code> when creating the Manager from <code>__moduleHelpers</code>.</li>
<li>Inside the Manager’s controller, read them via <code>this.__module.obj_args</code>.</li>
<li>When creating Instances, pass the options to each Instance’s <code>options</code> model using <code>.set()</code>.</li>
</ol>
<pre><code>(function() {
    var str_moduleName = 'productFilterUIManager';
    var obj_classdef = {
        arr_instances: [],
        start: function() {
            var self = this;
            var obj_instanceOptions = this.__module.obj_args.obj_instanceOptions || {};
            this.arr_instances = [];
            Array.each(
                document.querySelectorAll('[data-merconis-component~="product-filter-ui"]'),
                function(el_container) {
                    if (!el_container.retrieve('alreadyHandledBy_' + str_moduleName)) {
                        el_container.store('alreadyHandledBy_' + str_moduleName, true);
                    } else { return; }
                    var instance = lsjs.createModule({
                        __name: 'productFilterUIInstance',
                        __el_container: el_container
                    });
                    if (instance.__models && instance.__models.options) {
                        instance.__models.options.set(obj_instanceOptions);
                    }
                    self.arr_instances.push(instance);
                }
            );
            console.log(str_moduleName + ': Created ' + this.arr_instances.length + ' instance(s).', this.arr_instances);
        }
    };
    lsjs.addControllerClass(str_moduleName, obj_classdef);
    lsjs.__moduleHelpers[str_moduleName] = {
        self: null,
        start: function(obj_instanceOptions) {
            this.self = lsjs.createModule({
                __name: str_moduleName,
                obj_instanceOptions: obj_instanceOptions
            });
        }
    };
})();
</code></pre>

<h3>Example: productFilterUI Instance (View with Ajax)</h3>
<pre><code>(function() {
    var str_moduleName = 'productFilterUIInstance';
    var obj_classdef = {
        el_form: null,
        start: function() {
            this.el_form = this.__el_container.querySelector('form');
            if (!this.el_form) {
                console.warn(str_moduleName + ': No form found', this.__el_container);
                return;
            }
            lsjs.helpers.prepareFormForCajaxRequest(this.el_form);
            this.initUI();
        },
        initUI: function() {
            var submitBtn = this.el_form.querySelector('input[type="submit"]');
            if (submitBtn) submitBtn.style.display = 'none';
            this.el_form.addEventListener('submit', function(event) {
                if (!this.__models.options.data.bln_doNotUseAjax) {
                    event.preventDefault();
                    event.stopPropagation();
                    lsjs.loadingIndicator.__controller.show();
                    new Request.cajax({
                        url: this.el_form.getAttribute('action'),
                        method: 'post',
                        noCache: true,
                        bln_doNotModifyUrl: true,
                        cajaxMode: 'updateCompletely',
                        el_formToUseForFormData: this.el_form,
                        // MANDATORY: tell the server which elements to send back
                        obj_additionalFormData: {
                            'cajaxRequestData[requestedElementClass]': 'ajax-reload-by-filter'
                        },
                        onComplete: function() {
                            lsjs.loadingIndicator.__controller.hide();
                        }
                    }).send();
                }
            }.bind(this));
            // trigger submit via event so it can be intercepted
            this.el_form.addEventListener('change', function() {
                setTimeout(() => {
                    this.el_form.dispatchEvent(
                        new Event('submit', { cancelable: true, bubbles: true })
                    );
                }, 80);
            }.bind(this));
        }
    };
    lsjs.addViewClass(str_moduleName, obj_classdef);
})();
</code></pre>

<h3>Debugging Approach</h3>
<p>
The Manager stores each created Instance in <code>this.arr_instances</code>, accessible from browser console after startup:
</p>
<pre><code>lsjs.__moduleHelpers.productFilterUIManager.self.arr_instances
// First instance's form:
lsjs.__moduleHelpers.productFilterUIManager.self.arr_instances[0].el_form
</code></pre>

<hr>
<h2>9. CAJAX Usage Notes</h2>
<ul>
    <li><strong>Mandatory request data:</strong> In <code>Request.cajax</code>, always send
        <code>cajaxRequestData</code> so the server knows which DOM elements to return:
<pre><code>obj_additionalFormData: {
    'cajaxRequestData[requestedElementClass]': 'ajax-reload-by-filter'
}
</code></pre>
    </li>
    <li><strong>Unique IDs required:</strong> Each element returned via CAJAX must have a unique <code>id</code> so LSJS can map it for replacement in the DOM.</li>
    <li><strong>Reinitialization after CAJAX:</strong> When a CAJAX update replaces a module’s <code>__el_container</code>, all event bindings are lost. Re-run the module’s starter code inside a <code>cajax_domUpdate</code> handler. Use the passed <code>el_domReference</code> to limit the re-init scope:
<pre><code>window.addEvent('cajax_domUpdate', function(el_domReference) {
    lsjs.__moduleHelpers.productFilterUIManager.start();
    // Optionally scope to el_domReference if supported
});
</code></pre>
    </li>
</ul>

<hr>
<h2>10. Event Dispatch vs submit()</h2>
<p>
Calling a form’s <code>submit()</code> method bypasses <code>submit</code> event listeners.
If your Ajax intercept is bound to <code>submit</code>, dispatch a synthetic event instead:
</p>
<pre><code>form.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
</code></pre>

</body>
</html>