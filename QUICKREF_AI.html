<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LSJS Quick Reference</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.5;
        }

        h1, h2, h3 {
            color: #333;
        }

        pre, code {
            background: #f5f5f5;
            padding: 5px;
            border-radius: 4px;
            font-family: Consolas, monospace;
            font-size: 14px;
        }

        pre {
            overflow-x: auto;
            padding: 10px;
        }

        hr {
            margin: 30px 0;
        }
    </style>
</head>
<body>

<h1>LSJS Quick Reference — Leading Systems JavaScript Framework</h1>
<p><strong>Version:</strong> Internal documentation with current conventions, patterns, and best practices.</p>
<hr>

<h2>1. Overview</h2>
<ul>
    <li><strong>LSJS</strong> is a <strong>modular MVC‑like front‑end JS framework</strong> used in the
        <strong>Merconis</strong> shop system.
    </li>
    <li>Modules can exist inside:
        <ul>
            <li><code>lsjs/core/modules</code> → reusable core modules.</li>
            <li><code>lsjs/app/modules</code> → app‑specific modules.</li>
        </ul>
    </li>
    <li><code>app.js</code> defines which modules are initialized at runtime.</li>
</ul>

<hr>

<h2>2. Module Structure</h2>
<p>A typical LSJS module consists of up to three components:</p>
<pre>modules/
  moduleName/
    controller.js
    view.js
    models/
      options.js
</pre>

<h3>Roles in MVC</h3>
<ul>
  <li><strong>Controller</strong>: Coordinates logic, data flow between Models, and between Models and View. Avoids direct DOM manipulation unless unavoidable.</li>
  <li><strong>View</strong>: Owns <code>__el_container</code>, performs DOM lookups, manipulations, and binds UI event handlers. All UI behaviour and visual state changes should go in the View.</li>
  <li><strong>Model</strong>: Holds data and configuration; Views/Controllers use it for logic and rendering decisions.</li>
</ul>

<h3>controller.js</h3>
<pre><code>lsjs.addControllerClass(str_moduleName, obj_classdef);
</code></pre>
<p>For *visual UI modules*, Controller can remain minimal if no coordination logic is needed.</p>

<h3>view.js</h3>
<pre><code>lsjs.addViewClass(str_moduleName, obj_classdef);
</code></pre>
<p>Handles all UI work using <code>this.__el_container</code> as the instance root DOM node.</p>

<h3>models/options.js</h3>
<p>Stores default configuration and merges user-provided overrides.</p>
<pre><code>var obj_classdef_model = {
    name: 'options',
    data: {},
    start: function() {
        this.data = {
            str_containerSelector: '',
            bln_doNotUseAjax: false
        };
    },
    set: function(obj_options) {
        Object.merge(this.data, obj_options);
        this.__module.onModelLoaded();
    }
};
</code></pre>

<hr>
<h2>3. Creating a Simple Module</h2>
<ol>
    <li>Create folder:
        <pre>lsjs/app/modules/myModule/</pre>
    </li>
    <li>controller.js:
        <pre><code>(function() {
    var str_moduleName = 'myModule';
    var obj_classdef = {
        start: function() {
            console.log('Module started!');
        }
    };
    lsjs.addControllerClass(str_moduleName, obj_classdef);

    lsjs.__moduleHelpers[str_moduleName] = {
        self: null,
        start: function(obj_options) {
            this.self = lsjs.createModule({ __name: str_moduleName });
            if (this.self.__models &amp;&amp; this.self.__models.options) {
                this.self.__models.options.set(obj_options || {});
            }
        }
    };
})();
</code></pre>
    </li>
    <li>Start in app.js:
<pre><code>lsjs.__moduleHelpers.myModule.start({ /* options */ });
</code></pre>
    </li>
</ol>

<hr>

<h2>4. App Initialization Flow (app.js)</h2>
<pre><code>lsjs.__moduleHelpers.someModule.start({
    str_containerSelector: '.some-selector',
    someOption: true
});
</code></pre>
<p>Flow: <br> <code>Controller → Model(s) → View</code></p>

<hr>

<h2>5. Template Handling</h2>
<p>Provided by <code>lsjs_templateHandler.js</code>:</p>
        <ul>
            <li><code>lsjs.tpl.add(...)</code> → append rendered template as child.</li>
            <li><code>lsjs.tpl.replace(...)</code> → replace all children, then append.</li>
        </ul>

<pre><code>lsjs.tpl.register({
    myTemplate: function(data) { /* return HTML */ }
}, 'moduleName');
</code></pre>

<hr>

<h2>6. Key LSJS APIs</h2>
<ul>
    <li><code>lsjs.createModule({...})</code> → create a module instance</li>
    <li><code>lsjs.addControllerClass(name, def)</code> / <code>lsjs.addViewClass(name, def)</code></li>
    <li><code>lsjs.__moduleHelpers</code> registry for starting/stopping modules</li>
    <li><code>this.registerElements(container, namespace)</code> in views auto-registers DOM refs</li>
</ul>

<hr>

<h2>7. Patterns to Follow</h2>
<ul>
    <li>Always register app-startable modules in <code>lsjs.__moduleHelpers</code>.</li>
    <li>UI logic with <code>__el_container</code> belongs in the View.</li>
    <li>Keep <code>.start()</code> minimal in Controller unless coordinating data flow.</li>
    <li>Use <code>models/options.js</code> for default config+merges.</li>
    <li>Enhance existing DOM, when possible, to allow server rendering + progressive enhancement.</li>
</ul>

<hr>
<h2>8. Manager/Instance Pattern</h2>
<p>
For modules that can have multiple independent UI instances on a single page, LSJS uses a <strong>Manager/Instance</strong> pattern.
This pattern allows a Manager module to scan the DOM for relevant containers and create one Instance module for each container.
</p>

<h3>Directory Structure</h3>
<p>
Both the Manager and the Instance are technically separate LSJS modules, and each has its own folder inside a common parent directory for the overall feature:
</p>
<pre>
modules/
  myModule/
    myModuleManager/
      controller.js   &lt;-- Only file needed for Manager
    myModuleInstance/
      controller.js
      view.js
      models/
        options.js   (optional, if instance needs config)
</pre>
<p>
The Manager’s <code>controller.js</code> is the <strong>only file</strong> required for the Manager module — it has no View or Model because it does not directly handle DOM logic.
Its sole purpose is to find relevant DOM containers and create Instance modules.
</p>

<h3>Example: productFilterUI Manager</h3>
<pre><code>(function() {
    var str_moduleName = 'productFilterUIManager';
    var obj_classdef = {
        arr_instances: [], // store instances for debugging

        start: function() {
            this.arr_instances = [];
            Array.each(
              document.querySelectorAll('[data-merconis-component~="product-filter-ui"]'),
              function(el_container) {
                  if (!el_container.retrieve('alreadyHandledBy_' + str_moduleName)) {
                      el_container.store('alreadyHandledBy_' + str_moduleName, true);
                  } else { return; }
                  var instance = lsjs.createModule({
                      __name: 'productFilterUIInstance',
                      __el_container: el_container
                  });

                  // Store instance reference for debugging
                  this.arr_instances.push(instance);
              }.bind(this)
            );
            console.log(str_moduleName + ': created', this.arr_instances.length, 'instances', this.arr_instances);
        }
    };
    lsjs.addControllerClass(str_moduleName, obj_classdef);
    lsjs.__moduleHelpers[str_moduleName] = {
        self: null,
        start: function() {
            this.self = lsjs.createModule({ __name: str_moduleName });
            }
    };
})();
</code></pre>

<h3>Example: productFilterUI Instance</h3>
<pre><code>(function() {
    var str_moduleName = 'productFilterUIInstance';
    var obj_classdef = {
        start: function() { }
    };
    lsjs.addControllerClass(str_moduleName, obj_classdef);
})();
</code></pre>

<pre><code>(function() {
    var str_moduleName = 'productFilterUIInstance';
    var obj_classdef = {
        start: function() {
            this.el_form = this.__el_container.querySelector('form');
            if (!this.el_form) {
                console.warn(str_moduleName + ': No form found in container', this.__el_container);
                return;
            }
            this.initUI();
        },
        initUI: function() {
            var submitBtn = this.el_form.querySelector('input[type="submit"]');
            if (submitBtn) submitBtn.style.display = 'none';
            this.el_form.addEventListener('change', function() {
                setTimeout(() => { this.el_form.submit(); }, 80);
            }.bind(this));
        }
    };
    lsjs.addViewClass(str_moduleName, obj_classdef);
})();
</code></pre>

<h3>app.js Startup</h3>
<pre><code>lsjs.__moduleHelpers.productFilterUIManager.start();
</code></pre>

<hr>

<h3>Debugging Approach</h3>
<p>
The Manager stores each created Instance in <code>this.arr_instances</code>, which is also accessible from the browser console once the Manager has started:
</p>
<pre><code>// See all created instances
lsjs.__moduleHelpers.productFilterUIManager.self.arr_instances

// Access the first instance's form element
lsjs.__moduleHelpers.productFilterUIManager.self.arr_instances[0].el_form

// Call a method of an instance's view
lsjs.__moduleHelpers.productFilterUIManager.self.arr_instances[0].__view.initUI()
</code></pre>
<p>
This makes it easy to inspect and debug individual module instances directly in the console during development.
</p>

<p>
Using <strong>Manager/Instance</strong> ensures that:
<ul>
    <li>Multiple UI instances (e.g., multiple filter forms) work independently.</li>
    <li>DOM logic is entirely in the Instance's View, keeping the Manager simple.</li>
    <li>The Manager is responsible only for initialization and tracking of instances.</li>
</ul>
</p>

</body>
</html>